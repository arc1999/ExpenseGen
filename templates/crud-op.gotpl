package {{.Package}}

import(
"database/sql"
"gopkg.in/reform.v1"
	"gopkg.in/reform.v1/dialects/mysql"
	"net/http"
"context"
"fmt"
"log"
"strconv"
"github.com/go-chi/chi"
"github.com/go-chi/chi/middleware"
"github.com/go-chi/render"
_ "github.com/go-sql-driver/mysql"
	"os"
	"time"
)
var obj {{.Struct}}
type {{.SliceStruct}} []{{.Struct}}
var {{.Package}} {{.SliceStruct}}
var db *reform.DB
var err error
var req Createreq

func Init(){
          d,err:=sql.Open("mysql", "root:root@tcp(localhost:3306)/Expense?charset=utf8&parseTime=True")
        	if err != nil {
        		fmt.Println("ayush")
        		fmt.Println(err)
        	}
               lg := log.New(os.Stderr, "SQL: ", log.Flags())
        	db= reform.NewDB(d, mysql.Dialect, reform.NewPrintfLogger(lg.Printf))

       r := chi.NewRouter()
           r.Use(middleware.RequestID)
           r.Use(middleware.RealIP)
           r.Use(middleware.Logger)
           r.Use(middleware.Recoverer)
           r.Use(render.SetContentType(render.ContentTypeJSON))
           r.Route("/{{.Package}}", func(r chi.Router) {
               r.Post("/", Create)
               r.Get("/",GetAll)
               r.Route("/{id}", func(r chi.Router) {
                   r.Use(CrudContext)
                   r.Get("/",GetId)
                   r.Put("/",Update)
                   r.Delete("/",Delete)
               })
           })
           log.Fatal(http.ListenAndServe(":8080", r))
   }

func CrudContext(next http.Handler) http.Handler {
return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

ID := chi.URLParam(r, "id")
id,_:=strconv.Atoi(ID)
		temp,err :=db.FindByPrimaryKeyFrom({{.Struct}}Table,id)

		if err != nil {
        		fmt.Println(err)
        		return
        	}else{
			ctx := context.WithValue(r.Context(), "key", temp)
			next.ServeHTTP(w, r.WithContext(ctx))
		}
	})

}
func Create(writer http.ResponseWriter , request *http.Request){
err = render.Bind(request, &req)
	temp:=*req.{{.Struct}}
	temp.CreatedOn=time.Now()
	temp.UpdatedOn=time.Now()
	err=db.Save(&temp)
	if err != nil {
        fmt.Println(err)
        return
        }
	render.Render(writer, request,List1(&temp))
}
func GetId(writer http.ResponseWriter , request *http.Request){
 	temp:= request.Context().Value("key").(*{{.Struct}})
 		_ = render.Render(writer, request,List1(temp))

}
func GetAll(writer http.ResponseWriter , request *http.Request){
flag:=1
    tables, err := db.SelectRows({{.Struct}}Table, "WHERE id IS NOT NULL")
    if err != nil {
        fmt.Println(err)
        return
    }
    defer tables.Close()

    for flag!=0{
        err = db.NextRow(&obj, tables)
        if err!=nil{
            flag=0
        }else{
        {{.Package}}=append({{.Package}},obj)
        }
    }
    _=render.Render(writer, request, ListAll(&{{.Package}}))
}
func Update(writer http.ResponseWriter , request *http.Request){
s:=request.Context().Value("key").(*{{.Struct}})
var upreq Updatereq
err:= render.Bind(request,&upreq)
  if err != nil {
      log.Println(err)
      return
  }
   var temp {{.Struct}}
      temp=*upreq.{{.Struct}}

           s.Description=temp.Description
                  s.Type=temp.Type
                  s.Amount=temp.Amount
                  s.UpdatedOn=time.Now()

              err1 := db.Update(s)

      if err1 != nil{
                 fmt.Println(err)
                 return
             }else{
                fmt.Fprintf(writer,`{UpdateSuccess:True}`)

                  }
}
func Delete(writer http.ResponseWriter , request *http.Request){
s:=request.Context().Value("key").(*{{.Struct}})
    err=db.Delete(s)
    if err != nil {
        panic(err)
    }else{
        fmt.Fprintf(writer,`{DeleteSuccess:True}`)
    }
}
